<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="a76d531c-f31d-485b-bd92-fc09a187187f" name="Changes" comment="Liam and Eric. Finished gameplay class and added comments. Here we worked as a pair to follow the directions to create the core code for the game. We started with defining the variables, creating the physical game interface by drawing everything but the bricks and then calling in the class that creates the array for the bricks. Create a gameover/win scenario to allow for a restart of the game when all the bricks are cleared or the ball leaves the bottom of the screen. We then created the logic that allows for the game to work, like what happens when a ball hits the brick and how it affects the total bricks and overall scores. We were able to make sure that the ball stays on the grid by reversing the direction. Next we used the key events to move the paddle from user input and the rate at which it moves or when the enter key is hit to allow for restart. Overall this part of the code proved to be challenging based on the syntax that we were unfamilair with but logically it was very similar to what we had done in the past, which allowed for us to understand what we were doing even if we did not know exactly how to implement it." />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 0
}</component>
  <component name="ProjectId" id="2Yud8b9Opz9fFLYqJ4dCQ24XY7z" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
    &quot;onboarding.tips.debug.path&quot;: &quot;/Users/liamahearn/IdeaProjects/CSC111-Problemset4/src/Main.java&quot;
  }
}</component>
  <component name="RecentsManager">
    <key name="CreateClassDialog.RecentsKey">
      <recent name="" />
    </key>
  </component>
  <component name="RunManager">
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="brickBreaker.Main" />
      <module name="CSC111-Problemset4" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="brickBreaker.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Application.Main" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="a76d531c-f31d-485b-bd92-fc09a187187f" name="Changes" comment="" />
      <created>1701379239615</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1701379239615</updated>
    </task>
    <task id="LOCAL-00001" summary="Liam - set up main class">
      <option name="closed" value="true" />
      <created>1701960041684</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1701960041684</updated>
    </task>
    <task id="LOCAL-00002" summary="Liam and Eric, committing first part to be able to pull in mapgen to allow for error checking">
      <option name="closed" value="true" />
      <created>1702062069389</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1702062069390</updated>
    </task>
    <task id="LOCAL-00003" summary="Liam and Eric, committing first part to be able to pull in mapgen to allow for error checking">
      <option name="closed" value="true" />
      <created>1702062168560</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1702062168560</updated>
    </task>
    <task id="LOCAL-00004" summary="Liam and Eric. Finished gameplay class and added comments. Here we worked as a pair to follow the directions to create the core code for the game. We started with defining the variables, creating the physical game interface by drawing everything but the bricks and then calling in the class that creates the array for the bricks. Create a gameover/win scenario to allow for a restart of the game when all the bricks are cleared or the ball leaves the bottom of the screen. We then created the logic that allows for the game to work, like what happens when a ball hits the brick and how it affects the total bricks and overall scores. We were able to make sure that the ball stays on the grid by reversing the direction. Next we used the key events to move the paddle from user input and the rate at which it moves or when the enter key is hit to allow for restart. Overall this part of the code proved to be challenging based on the syntax that we were unfamilair with but logically it was very similar to what we had done in the past, which allowed for us to understand what we were doing even if we did not know exactly how to implement it.">
      <option name="closed" value="true" />
      <created>1702069598139</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1702069598141</updated>
    </task>
    <option name="localTasksCounter" value="5" />
    <servers />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="Liam - set up main class" />
    <MESSAGE value="Liam and Eric, committing first part to be able to pull in mapgen to allow for error checking" />
    <MESSAGE value="Merge remote-tracking branch 'origin/main'&#10;&#10;# Conflicts:&#10;#&#9;src/brickBreaker/Main.java" />
    <MESSAGE value="Liam and Eric. Finished gameplay class and added comments. Here we worked as a pair to follow the directions to create the core code for the game. We started with defining the variables, creating the physical game interface by drawing everything but the bricks and then calling in the class that creates the array for the bricks. Create a gameover/win scenario to allow for a restart of the game when all the bricks are cleared or the ball leaves the bottom of the screen. We then created the logic that allows for the game to work, like what happens when a ball hits the brick and how it affects the total bricks and overall scores. We were able to make sure that the ball stays on the grid by reversing the direction. Next we used the key events to move the paddle from user input and the rate at which it moves or when the enter key is hit to allow for restart. Overall this part of the code proved to be challenging based on the syntax that we were unfamilair with but logically it was very similar to what we had done in the past, which allowed for us to understand what we were doing even if we did not know exactly how to implement it." />
    <option name="LAST_COMMIT_MESSAGE" value="Liam and Eric. Finished gameplay class and added comments. Here we worked as a pair to follow the directions to create the core code for the game. We started with defining the variables, creating the physical game interface by drawing everything but the bricks and then calling in the class that creates the array for the bricks. Create a gameover/win scenario to allow for a restart of the game when all the bricks are cleared or the ball leaves the bottom of the screen. We then created the logic that allows for the game to work, like what happens when a ball hits the brick and how it affects the total bricks and overall scores. We were able to make sure that the ball stays on the grid by reversing the direction. Next we used the key events to move the paddle from user input and the rate at which it moves or when the enter key is hit to allow for restart. Overall this part of the code proved to be challenging based on the syntax that we were unfamilair with but logically it was very similar to what we had done in the past, which allowed for us to understand what we were doing even if we did not know exactly how to implement it." />
  </component>
</project>